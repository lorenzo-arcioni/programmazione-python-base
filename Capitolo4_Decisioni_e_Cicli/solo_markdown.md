# üîÑ Iterabili e Iteratori in Python

## üìö Introduzione

In Python, **l'iterazione** √® uno dei concetti fondamentali per la manipolazione e l'elaborazione di collezioni di dati. Alla base di ogni ciclo `for`, `while` o costrutto iterativo, esiste un insieme di meccanismi che coinvolgono due concetti strettamente legati:

- **Iterabile** (*Iterable*)
- **Iteratore** (*Iterator*)

Questi concetti non rappresentano semplici "tipi di oggetti", ma definiscono **comportamenti specifici** che gli oggetti possono esibire quando vengono usati in contesti iterativi. Comprendere come funzionano questi comportamenti permette di scrivere codice pi√π efficiente, controllato e conforme ai principi del linguaggio Python.

## üîÅ Cos'√® un Iterabile?

Un **iterabile** √® un oggetto che rappresenta una **sequenza di elementi** e che √® in grado di **fornire un iteratore** per accedere a questi elementi uno alla volta.

Un oggetto √® considerato **iterabile** se implementa il **protocollo dell'iterabile**, ovvero se:

- **implementa un metodo speciale chiamato `__iter__()`**
- questo metodo restituisce un **oggetto iteratore**

Un iterabile √® quindi **una collezione di dati** che non √® direttamente responsabile di fornire ciascun valore uno dopo l'altro, ma **sa come creare** un oggetto incaricato di farlo.

Come abbiamo potuto osservare, se un oggetto implementa il metodo `__iter__()`, quando esso viene chiamato, restituisce un oggetto **iteratore**.

## üîÑ Cos'√® un Iteratore?

Un **iteratore** √® un oggetto che **mantiene uno stato interno** e che sa **come restituire i valori successivi** di una sequenza, uno alla volta, fino all'esaurimento degli elementi.

Un oggetto √® considerato **un iteratore** se:

- **implementa il metodo `__next__()`**, che restituisce l‚Äôelemento successivo nella sequenza a ogni chiamata
- **implementa anche il metodo `__iter__()`**, che restituisce l'oggetto stesso (quindi un iteratore √® anche un iterabile)

La caratteristica principale dell‚Äôiteratore √® che, una volta consumati tutti gli elementi, ogni ulteriore richiesta tramite `__next__()` causer√† il sollevamento di un‚Äô**eccezione di tipo `StopIteration`**, che segnala la **fine dell‚Äôiterazione**.

Quindi l'iteratore si "consuma" ogni volta che usiamo il metodo `__next__()`. Quindi se utilizziamo il metodo ancora una volta, otteniamo un errore dall'interprete:

## ‚öôÔ∏è Differenza tra Iterabile e Iteratore

| Caratteristica | Iterabile | Iteratore |
|----------------|-----------|-----------|
| Responsabilit√† | Sa come **fornire un iteratore** | Sa come **restituire i valori uno a uno** |
| Metodo richiesto | `__iter__()` | `__iter__()` e `__next__()` |
| Stato interno | Non mantiene stato | Mantiene uno **stato interno** tra chiamate successive |
| Riutilizzabile | Pu√≤ essere usato per creare **nuovi iteratori** ogni volta | **Non riutilizzabile** una volta esauriti gli elementi |
| Tipico esempio | Liste, stringhe, tuple | Oggetto restituito da `iter()` |

Quindi, un iterabile pu√≤ fornire uno (o pi√π) iteratori, ovvero ha la potenzialit√† di generare un iteratore.

### üóÇÔ∏è Dizionari: iterabili e iteratori

- Un **dizionario** in Python √® un oggetto **iterabile**, il che significa che si pu√≤ ottenere un iteratore da esso chiamando il metodo `__iter__()`.
- L‚Äôiteratore ottenuto da un dizionario scorre **le chiavi** del dizionario, una alla volta.
- L‚Äôiteratore implementa il metodo `__next__()`, che restituisce la chiave successiva ogni volta che viene chiamato.
- Quando si raggiungono tutte le chiavi, una chiamata successiva a `__next__()` genera un‚Äôeccezione `StopIteration` (tipico comportamento di tutti gli iteratori).

**In sintesi:**

- Dizionario = iterabile (puoi chiamare `__iter__()` su di esso)  
- Iteratore del dizionario = oggetto con `__next__()` che restituisce le chiavi, una alla volta

Se vuoi iterare sui valori o sulle coppie chiave-valore, puoi ottenere iterabili e iteratori specifici usando i metodi `.values()` e `.items()` del dizionario, che funzionano in modo analogo.  

## üß† Perch√© questa distinzione √® importante?

Questa distinzione permette a Python di:

- **Separare la struttura dei dati dalla logica di accesso** sequenziale: un iterabile pu√≤ essere semplice da rappresentare, mentre l‚Äôiteratore si occupa della logica dell‚Äôavanzamento.
- **Supportare la lazy evaluation**: gli iteratori possono produrre dati ‚Äúsu richiesta‚Äù senza doverli tenere tutti in memoria.
- **Consentire l‚Äôuso di cicli `for`**, funzioni come `map()`, `filter()`, e comprensioni, basandosi sul protocollo dell‚Äôiterazione.

## üß≠ Protocollo dell‚ÄôIterazione in breve

1. Quando un oggetto viene usato in un ciclo `for`, Python chiama il suo metodo `__iter__()`.
2. Questo metodo restituisce un oggetto **iteratore**.
3. Python continua a chiamare il metodo `__next__()` sull‚Äôiteratore per ottenere ciascun valore.
4. Quando non ci sono pi√π valori, il metodo `__next__()` solleva l‚Äôeccezione `StopIteration`.
5. Il ciclo `for` intercetta l‚Äôeccezione e termina l‚Äôiterazione.

## üß© Alcune propriet√† aggiuntive degli iteratori

- Gli **iteratori sono consumabili**: una volta iterati completamente, non possono essere riutilizzati senza ricrearne uno nuovo.
- Gli **iteratori non hanno lunghezza** nota a priori, a differenza delle liste o tuple.
- La loro natura li rende ideali per lavorare con **flussi di dati infiniti o grandi** (es. file, stream, generatori).

### üß¨ Iteratori e gestione efficiente di grandi quantit√† di dati

Quando lavoriamo con dataset di dimensioni molto grandi ‚Äî ad esempio una sequenza genomica composta da miliardi di caratteri (A, C, G, T) ‚Äî caricare l'intera struttura in memoria pu√≤ essere estremamente inefficiente o addirittura impossibile. Strutture come `list`, `str` o `tuple` contengono tutti i dati in RAM, il che non √® scalabile per file di grandi dimensioni.

#### ‚úÖ Iteratori come soluzione

Gli **iteratori** permettono di elaborare dati **uno alla volta**, senza bisogno di caricare l'intera sequenza in memoria. Questo approccio si chiama **lazy evaluation** (valutazione pigra): i dati vengono forniti solo quando richiesti, tramite il metodo `__next__()`.

In questo modo:

- ‚úÖ l'utilizzo di memoria √® minimo (viene mantenuto solo l'elemento corrente),
- ‚úÖ l'applicazione pu√≤ scalare facilmente a dataset enormi,
- ‚úÖ si riducono i tempi di caricamento iniziale.

#### üìå Esempio realistico

Nel caso di un file contenente il genoma umano (oltre 3 miliardi di caratteri), √® possibile aprirlo come un iteratore di caratteri o righe. Python fornisce oggetti file che **sono gi√† iteratori**: √® quindi possibile leggere il file **una riga alla volta**, con un impatto minimo sulla memoria.

Questo approccio √® utile, ad esempio, per:

- contare la frequenza di una base (es. quante volte appare "G"),
- cercare un pattern genetico,
- validare o convertire il formato dei dati,
- generare statistiche in tempo reale.

Usando un iteratore, possiamo **analizzare il file pezzo per pezzo**, senza mai caricare tutto in memoria. Questo √® un vantaggio chiave nella programmazione di basso livello su grandi dataset.

Nella cella seguente, viene mostrato un esempio concreto in Python.

## üß∞ Oggetti built-in iterabili

Python offre molte **strutture dati** che sono nativamente iterabili:

- Liste, tuple, insiemi e dizionari
- Stringhe
- Oggetti restituiti da funzioni come `range()`, `zip()`, `enumerate()`
- File aperti (iterano riga per riga)
- Oggetti definiti dall‚Äôutente che implementano `__iter__()`

### üìè Oggetto di tipo `range`: Iterabile ma non Iteratore

- L‚Äôoggetto `range` rappresenta una sequenza di numeri ed √® **iterabile**, il che significa che pu√≤ restituire un iteratore tramite il metodo `__iter__()`.
- Tuttavia, `range` **non √® di per s√© un iteratore**, perch√© non implementa il metodo `__next__()`.
- Per scorrere gli elementi di un `range`, √® necessario prima ottenere un iteratore da esso chiamando `__iter__()`.
- L‚Äôiteratore restituito da `range.__iter__()` implementa `__next__()` e permette di ottenere gli elementi uno per uno.

**Riassunto:**

| Tipo oggetto   | `__iter__()` | `__next__()` | Cos‚Äô√®?         |
|----------------|--------------|--------------|----------------|
| `range`        | S√¨           | No           | Iterabile      |
| `range.__iter__()` | S√¨        | S√¨           | Iteratore      |

### üîó Uso di `zip`: iteratore di tuple

- La funzione built-in `zip()` prende due o pi√π iterabili e restituisce un **iteratore** che produce tuple composte dagli elementi corrispondenti di ogni iterabile.
- `zip` √® un **iteratore** perch√© implementa `__next__()`, quindi pu√≤ essere usato direttamente per ottenere gli elementi uno alla volta.
- Le tuple restituite da `zip` combinano i valori degli input posizionati allo stesso indice.

**Esempio di comportamento:**

- Input: liste `[1, 2, 3]` e `['a', 'b', 'c']`
- Output `zip`: (1, 'a'), (2, 'b'), (3, 'c')

### üî¢ Uso di `enumerate`: iteratore con indice

- `enumerate()` prende un iterabile e restituisce un **iteratore** che produce tuple `(indice, elemento)`.
- √à molto utile quando si vuole accedere sia all‚Äôelemento sia alla sua posizione durante l‚Äôiterazione.
- Come `zip`, `enumerate` implementa `__next__()` e quindi √® un iteratore pronto all‚Äôuso.

**Esempio di comportamento:**

- Input: lista `['mela', 'banana', 'ciliegia']`
- Output `enumerate`: (0, 'mela'), (1, 'banana'), (2, 'ciliegia')

### üîÑ Uso di `reversed()`: iteratore inverso

- La funzione built-in `reversed()` prende una sequenza (come una lista o una stringa) e restituisce un **iteratore** che attraversa gli elementi in ordine inverso.
- `reversed` √® un iteratore perch√© implementa `__next__()`, quindi possiamo usarlo per scorrere gli elementi a ritroso uno alla volta.
- Non modifica l‚Äôoggetto originale, ma crea un iteratore che genera gli elementi in senso opposto.

**Esempio di comportamento:**

- Input: lista `[10, 20, 30]`
- Output `reversed`: 30, 20, 10

### üìã `sorted()`: restituisce una nuova lista ordinata

- La funzione `sorted()` prende un iterabile e restituisce una **nuova lista** contenente gli elementi ordinati.
- La lista risultante √® iterabile, ma **non √® un iteratore**.
- Per ottenere un iteratore dalla lista ordinata, si pu√≤ usare la funzione `iter()`.

### üîß `iter()`: creare un iteratore da un iterabile

- `iter()` √® una funzione built-in che prende un oggetto iterabile e restituisce un **iteratore**.
- Questo iteratore pu√≤ essere usato per ottenere gli elementi uno alla volta con `__next__()`.
- √à il modo standard per trasformare un iterabile in un iteratore esplicitamente.

## üìå Conclusione

Capire la differenza tra **iterabili** e **iteratori** permette di padroneggiare meglio il funzionamento dei cicli, delle comprensioni, delle funzioni di ordine superiore e dei generatori. Questo rende il programmatore capace non solo di usare Python in modo pi√π idiomatico e potente, ma anche di creare oggetti personalizzati che si integrano perfettamente con il sistema di iterazione del linguaggio.

